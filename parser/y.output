Terminals unused in grammar

    RECEIVE
    SHORT_VAR
    VARIADIC_PARAM
    SELECTOR
    LOGICAL_NOT
    WHILE
    SWITCH
    CASE
    DEFAULT
    IMPORT
    APPEND
    LEN
    PRINT
    CHAN
    CONST
    DEFER
    FALLTHROUGH
    GO
    GOTO
    INTERFACE
    MAP
    RANGE
    SELECT
    STRUCT
    TYPE
    LSQPAREN
    RSQPAREN
    COMMA
    COLON
    MULTI_LINE_COMMENT


State 17 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: PackageClause function_declaration

    2 PackageClause: PACKAGE IDENTIFIER

    3 declaration: VAR IDENTIFIER type
    4            | VAR IDENTIFIER type ASSIGN expression
    5            | VAR IDENTIFIER ASSIGN expression

    6 function_declaration: FUNCTION IDENTIFIER LPAREN RPAREN block_stmt

    7 thing: IDENTIFIER
    8      | literal

    9 term: IDENTIFIER
   10     | literal
   11     | LPAREN expression RPAREN

   12 expression: term
   13           | binary_op

   14 binary_op: expression LOGICAL_OR term
   15          | expression LOGICAL_AND term
   16          | expression EQUAL_EQUAL term
   17          | expression NOT_EQUAL term
   18          | expression LESS_THAN_OR_EQUAL term
   19          | expression GREATER_THAN_OR_EQUAL term
   20          | expression LESS_THAN term
   21          | expression GREATER_THAN term
   22          | expression PLUS term
   23          | expression MINUS term
   24          | expression BITWISE_OR term
   25          | expression BITWISE_XOR term
   26          | expression TIMES term
   27          | expression DIVIDE term
   28          | expression MODULO term
   29          | expression RIGHT_SHIFT term
   30          | expression LEFT_SHIFT term
   31          | expression BITWISE_AND term
   32          | expression BIT_CLEAR term

   33 statement: declaration statement
   34          | simple_stmt statement
   35          | return_stmt statement
   36          | BREAK statement
   37          | CONTINUE statement
   38          | block_stmt statement
   39          | if_stmt statement
   40          | for_stmt statement
   41          | println_stmt statement
   42          | COMMENT statement
   43          | ε

   44 simple_stmt: inc_dec_stmt
   45            | assignment

   46 inc_dec_stmt: IDENTIFIER INCREMENT
   47             | IDENTIFIER DECREMENT

   48 assignment: IDENTIFIER ASSIGN expression
   49           | IDENTIFIER assign_op expression

   50 assign_op: add_op_eq
   51          | mul_op_eq

   52 add_op_eq: ADD_ASSIGN
   53          | SUB_ASSIGN
   54          | OR_ASSIGN
   55          | XOR_ASSIGN

   56 mul_op_eq: MUL_ASSIGN
   57          | DIV_ASSIGN
   58          | MOD_ASSIGN
   59          | LEFT_SHIFT_ASSIGN
   60          | RIGHT_SHIFT_ASSIGN
   61          | AND_ASSIGN
   62          | CLEAR_ASSIGN

   63 return_stmt: RETURN return_

   64 return_: thing
   65        | ε

   66 block_stmt: LBRACE statement RBRACE

   67 boolean_exp: term LOGICAL_OR term
   68            | term LOGICAL_AND term
   69            | term EQUAL_EQUAL term
   70            | term NOT_EQUAL term
   71            | term LESS_THAN_OR_EQUAL term
   72            | term GREATER_THAN_OR_EQUAL term
   73            | term LESS_THAN term
   74            | term GREATER_THAN term

   75 if_stmt: IF boolean_exp block_stmt
   76        | IF boolean_exp block_stmt ELSE if_stmt
   77        | IF boolean_exp block_stmt ELSE block_stmt

   78 for_stmt: FOR for_clause block_stmt

   79 for_clause: assignment SEMICOLON boolean_exp SEMICOLON simple_stmt

   80 println_stmt: PRINTLN LPAREN IDENTIFIER RPAREN
   81             | PRINTLN LPAREN STRING RPAREN

   82 type: INT_TYPE
   83     | STRING_TYPE
   84     | BOOL_TYPE

   85 literal: INTEGER
   86        | STRING
   87        | FLOAT
   88        | BOOLEAN


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    PLUS <nd_obj> (258) 22
    MINUS <nd_obj> (259) 23
    TIMES <nd_obj> (260) 26
    DIVIDE <nd_obj> (261) 27
    ASSIGN <nd_obj> (262) 4 5 48
    MODULO <nd_obj> (263) 28
    BITWISE_AND <nd_obj> (264) 31
    BITWISE_OR <nd_obj> (265) 24
    BITWISE_XOR <nd_obj> (266) 25
    BIT_CLEAR <nd_obj> (267) 32
    LEFT_SHIFT <nd_obj> (268) 30
    RIGHT_SHIFT <nd_obj> (269) 29
    ADD_ASSIGN <nd_obj> (270) 52
    SUB_ASSIGN <nd_obj> (271) 53
    MUL_ASSIGN <nd_obj> (272) 56
    DIV_ASSIGN <nd_obj> (273) 57
    MOD_ASSIGN <nd_obj> (274) 58
    AND_ASSIGN <nd_obj> (275) 61
    OR_ASSIGN <nd_obj> (276) 54
    XOR_ASSIGN <nd_obj> (277) 55
    LEFT_SHIFT_ASSIGN <nd_obj> (278) 59
    RIGHT_SHIFT_ASSIGN <nd_obj> (279) 60
    INCREMENT <nd_obj> (280) 46
    DECREMENT <nd_obj> (281) 47
    RECEIVE <nd_obj> (282)
    CLEAR_ASSIGN <nd_obj> (283) 62
    SHORT_VAR <nd_obj> (284)
    VARIADIC_PARAM <nd_obj> (285)
    SELECTOR <nd_obj> (286)
    EQUAL_EQUAL <nd_obj> (287) 16 69
    NOT_EQUAL <nd_obj> (288) 17 70
    LESS_THAN <nd_obj> (289) 20 73
    LESS_THAN_OR_EQUAL <nd_obj> (290) 18 71
    GREATER_THAN <nd_obj> (291) 21 74
    GREATER_THAN_OR_EQUAL <nd_obj> (292) 19 72
    LOGICAL_AND <nd_obj> (293) 15 68
    LOGICAL_OR <nd_obj> (294) 14 67
    LOGICAL_NOT <nd_obj> (295)
    IF <nd_obj> (296) 75 76 77
    ELSE <nd_obj> (297) 76 77
    WHILE <nd_obj> (298)
    FOR <nd_obj> (299) 78
    SWITCH <nd_obj> (300)
    CASE <nd_obj> (301)
    DEFAULT <nd_obj> (302)
    BREAK <nd_obj> (303) 36
    CONTINUE <nd_obj> (304) 37
    RETURN <nd_obj> (305) 63
    VAR <nd_obj> (306) 3 4 5
    INT_TYPE <nd_obj> (307) 82
    BOOL_TYPE <nd_obj> (308) 84
    STRING_TYPE <nd_obj> (309) 83
    IMPORT <nd_obj> (310)
    FUNCTION <nd_obj> (311) 6
    APPEND <nd_obj> (312)
    LEN <nd_obj> (313)
    PRINT <nd_obj> (314)
    PRINTLN <nd_obj> (315) 80 81
    PACKAGE <nd_obj> (316) 2
    CHAN <nd_obj> (317)
    CONST <nd_obj> (318)
    DEFER <nd_obj> (319)
    FALLTHROUGH <nd_obj> (320)
    GO <nd_obj> (321)
    GOTO <nd_obj> (322)
    INTERFACE <nd_obj> (323)
    MAP <nd_obj> (324)
    RANGE <nd_obj> (325)
    SELECT <nd_obj> (326)
    STRUCT <nd_obj> (327)
    TYPE <nd_obj> (328)
    LPAREN <nd_obj> (329) 6 11 80 81
    RPAREN <nd_obj> (330) 6 11 80 81
    LBRACE <nd_obj> (331) 66
    RBRACE <nd_obj> (332) 66
    LSQPAREN <nd_obj> (333)
    RSQPAREN <nd_obj> (334)
    SEMICOLON <nd_obj> (335) 79
    COMMA <nd_obj> (336)
    COLON <nd_obj> (337)
    BOOLEAN <nd_obj> (338) 88
    IDENTIFIER <nd_obj> (339) 2 3 4 5 6 7 9 46 47 48 49 80
    INTEGER <nd_obj> (340) 85
    STRING <nd_obj> (341) 81 86
    FLOAT <nd_obj> (342) 87
    COMMENT <nd_obj> (343) 42
    MULTI_LINE_COMMENT <nd_obj> (344)


Nonterminals, with rules where they appear

    $accept (90)
        on left: 0
    program <nd_obj> (91)
        on left: 1
        on right: 0
    PackageClause <nd_obj> (92)
        on left: 2
        on right: 1
    declaration <nd_obj> (93)
        on left: 3 4 5
        on right: 33
    function_declaration <nd_obj> (94)
        on left: 6
        on right: 1
    thing <nd_obj> (95)
        on left: 7 8
        on right: 64
    term <nd_obj> (96)
        on left: 9 10 11
        on right: 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 67 68 69 70 71 72 73 74
    expression <nd_obj> (97)
        on left: 12 13
        on right: 4 5 11 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 48 49
    binary_op <nd_obj> (98)
        on left: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
        on right: 13
    statement <nd_obj> (99)
        on left: 33 34 35 36 37 38 39 40 41 42 43
        on right: 33 34 35 36 37 38 39 40 41 42 66
    simple_stmt <nd_obj> (100)
        on left: 44 45
        on right: 34 79
    inc_dec_stmt <nd_obj> (101)
        on left: 46 47
        on right: 44
    assignment <nd_obj> (102)
        on left: 48 49
        on right: 45 79
    assign_op <nd_obj> (103)
        on left: 50 51
        on right: 49
    add_op_eq <nd_obj> (104)
        on left: 52 53 54 55
        on right: 50
    mul_op_eq <nd_obj> (105)
        on left: 56 57 58 59 60 61 62
        on right: 51
    return_stmt <nd_obj> (106)
        on left: 63
        on right: 35
    return_ <nd_obj> (107)
        on left: 64 65
        on right: 63
    block_stmt <nd_obj> (108)
        on left: 66
        on right: 6 38 75 76 77 78
    boolean_exp <nd_obj> (109)
        on left: 67 68 69 70 71 72 73 74
        on right: 75 76 77 79
    if_stmt <nd_obj> (110)
        on left: 75 76 77
        on right: 39 76
    for_stmt <nd_obj> (111)
        on left: 78
        on right: 40
    for_clause <nd_obj> (112)
        on left: 79
        on right: 78
    println_stmt <nd_obj> (113)
        on left: 80 81
        on right: 41
    type <nd_obj> (114)
        on left: 82 83 84
        on right: 3 4
    literal <nd_obj> (115)
        on left: 85 86 87 88
        on right: 8 10


State 0

    0 $accept: • program $end

    PACKAGE  shift, and go to state 1

    program        go to state 2
    PackageClause  go to state 3


State 1

    2 PackageClause: PACKAGE • IDENTIFIER

    IDENTIFIER  shift, and go to state 4


State 2

    0 $accept: program • $end

    $end  shift, and go to state 5


State 3

    1 program: PackageClause • function_declaration

    FUNCTION  shift, and go to state 6

    function_declaration  go to state 7


State 4

    2 PackageClause: PACKAGE IDENTIFIER •

    $default  reduce using rule 2 (PackageClause)


State 5

    0 $accept: program $end •

    $default  accept


State 6

    6 function_declaration: FUNCTION • IDENTIFIER LPAREN RPAREN block_stmt

    IDENTIFIER  shift, and go to state 8


State 7

    1 program: PackageClause function_declaration •

    $default  reduce using rule 1 (program)


State 8

    6 function_declaration: FUNCTION IDENTIFIER • LPAREN RPAREN block_stmt

    LPAREN  shift, and go to state 9


State 9

    6 function_declaration: FUNCTION IDENTIFIER LPAREN • RPAREN block_stmt

    RPAREN  shift, and go to state 10


State 10

    6 function_declaration: FUNCTION IDENTIFIER LPAREN RPAREN • block_stmt

    LBRACE  shift, and go to state 11

    block_stmt  go to state 12


State 11

   66 block_stmt: LBRACE • statement RBRACE

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 23
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 12

    6 function_declaration: FUNCTION IDENTIFIER LPAREN RPAREN block_stmt •

    $default  reduce using rule 6 (function_declaration)


State 13

   75 if_stmt: IF • boolean_exp block_stmt
   76        | IF • boolean_exp block_stmt ELSE if_stmt
   77        | IF • boolean_exp block_stmt ELSE block_stmt

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term         go to state 38
    boolean_exp  go to state 39
    literal      go to state 40


State 14

   78 for_stmt: FOR • for_clause block_stmt

    IDENTIFIER  shift, and go to state 41

    assignment  go to state 42
    for_clause  go to state 43


State 15

   36 statement: BREAK • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 44
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 16

   37 statement: CONTINUE • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 45
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 17

   63 return_stmt: RETURN • return_

    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 46
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    IDENTIFIER  [reduce using rule 65 (return_)]
    $default    reduce using rule 65 (return_)

    thing    go to state 47
    return_  go to state 48
    literal  go to state 49

    shift/reduce conflict on token IDENTIFIER:
       65 return_: ε •
        7 thing: • IDENTIFIER
      First example: statement
      Shift derivation
        statement
        ↳ 35: statement
      Second example: IDENTIFIER
      Reduce derivation
        statement
        ↳ 35: IDENTIFIER



State 18

    3 declaration: VAR • IDENTIFIER type
    4            | VAR • IDENTIFIER type ASSIGN expression
    5            | VAR • IDENTIFIER ASSIGN expression

    IDENTIFIER  shift, and go to state 50


State 19

   80 println_stmt: PRINTLN • LPAREN IDENTIFIER RPAREN
   81             | PRINTLN • LPAREN STRING RPAREN

    LPAREN  shift, and go to state 51


State 20

   46 inc_dec_stmt: IDENTIFIER • INCREMENT
   47             | IDENTIFIER • DECREMENT
   48 assignment: IDENTIFIER • ASSIGN expression
   49           | IDENTIFIER • assign_op expression

    ASSIGN              shift, and go to state 52
    ADD_ASSIGN          shift, and go to state 53
    SUB_ASSIGN          shift, and go to state 54
    MUL_ASSIGN          shift, and go to state 55
    DIV_ASSIGN          shift, and go to state 56
    MOD_ASSIGN          shift, and go to state 57
    AND_ASSIGN          shift, and go to state 58
    OR_ASSIGN           shift, and go to state 59
    XOR_ASSIGN          shift, and go to state 60
    LEFT_SHIFT_ASSIGN   shift, and go to state 61
    RIGHT_SHIFT_ASSIGN  shift, and go to state 62
    INCREMENT           shift, and go to state 63
    DECREMENT           shift, and go to state 64
    CLEAR_ASSIGN        shift, and go to state 65

    assign_op  go to state 66
    add_op_eq  go to state 67
    mul_op_eq  go to state 68


State 21

   42 statement: COMMENT • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 69
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 22

   33 statement: declaration • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 70
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 23

   66 block_stmt: LBRACE statement • RBRACE

    RBRACE  shift, and go to state 71


State 24

   34 statement: simple_stmt • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 72
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 25

   44 simple_stmt: inc_dec_stmt •

    $default  reduce using rule 44 (simple_stmt)


State 26

   45 simple_stmt: assignment •

    $default  reduce using rule 45 (simple_stmt)


State 27

   35 statement: return_stmt • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 73
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 28

   38 statement: block_stmt • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 74
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 29

   39 statement: if_stmt • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 75
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 30

   40 statement: for_stmt • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 76
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 31

   41 statement: println_stmt • statement

    IF          shift, and go to state 13
    FOR         shift, and go to state 14
    BREAK       shift, and go to state 15
    CONTINUE    shift, and go to state 16
    RETURN      shift, and go to state 17
    VAR         shift, and go to state 18
    PRINTLN     shift, and go to state 19
    LBRACE      shift, and go to state 11
    IDENTIFIER  shift, and go to state 20
    COMMENT     shift, and go to state 21

    $default  reduce using rule 43 (statement)

    declaration   go to state 22
    statement     go to state 77
    simple_stmt   go to state 24
    inc_dec_stmt  go to state 25
    assignment    go to state 26
    return_stmt   go to state 27
    block_stmt    go to state 28
    if_stmt       go to state 29
    for_stmt      go to state 30
    println_stmt  go to state 31


State 32

   11 term: LPAREN • expression RPAREN

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term        go to state 78
    expression  go to state 79
    binary_op   go to state 80
    literal     go to state 40


State 33

   88 literal: BOOLEAN •

    $default  reduce using rule 88 (literal)


State 34

    9 term: IDENTIFIER •

    $default  reduce using rule 9 (term)


State 35

   85 literal: INTEGER •

    $default  reduce using rule 85 (literal)


State 36

   86 literal: STRING •

    $default  reduce using rule 86 (literal)


State 37

   87 literal: FLOAT •

    $default  reduce using rule 87 (literal)


State 38

   67 boolean_exp: term • LOGICAL_OR term
   68            | term • LOGICAL_AND term
   69            | term • EQUAL_EQUAL term
   70            | term • NOT_EQUAL term
   71            | term • LESS_THAN_OR_EQUAL term
   72            | term • GREATER_THAN_OR_EQUAL term
   73            | term • LESS_THAN term
   74            | term • GREATER_THAN term

    EQUAL_EQUAL            shift, and go to state 81
    NOT_EQUAL              shift, and go to state 82
    LESS_THAN              shift, and go to state 83
    LESS_THAN_OR_EQUAL     shift, and go to state 84
    GREATER_THAN           shift, and go to state 85
    GREATER_THAN_OR_EQUAL  shift, and go to state 86
    LOGICAL_AND            shift, and go to state 87
    LOGICAL_OR             shift, and go to state 88


State 39

   75 if_stmt: IF boolean_exp • block_stmt
   76        | IF boolean_exp • block_stmt ELSE if_stmt
   77        | IF boolean_exp • block_stmt ELSE block_stmt

    LBRACE  shift, and go to state 11

    block_stmt  go to state 89


State 40

   10 term: literal •

    $default  reduce using rule 10 (term)


State 41

   48 assignment: IDENTIFIER • ASSIGN expression
   49           | IDENTIFIER • assign_op expression

    ASSIGN              shift, and go to state 52
    ADD_ASSIGN          shift, and go to state 53
    SUB_ASSIGN          shift, and go to state 54
    MUL_ASSIGN          shift, and go to state 55
    DIV_ASSIGN          shift, and go to state 56
    MOD_ASSIGN          shift, and go to state 57
    AND_ASSIGN          shift, and go to state 58
    OR_ASSIGN           shift, and go to state 59
    XOR_ASSIGN          shift, and go to state 60
    LEFT_SHIFT_ASSIGN   shift, and go to state 61
    RIGHT_SHIFT_ASSIGN  shift, and go to state 62
    CLEAR_ASSIGN        shift, and go to state 65

    assign_op  go to state 66
    add_op_eq  go to state 67
    mul_op_eq  go to state 68


State 42

   79 for_clause: assignment • SEMICOLON boolean_exp SEMICOLON simple_stmt

    SEMICOLON  shift, and go to state 90


State 43

   78 for_stmt: FOR for_clause • block_stmt

    LBRACE  shift, and go to state 11

    block_stmt  go to state 91


State 44

   36 statement: BREAK statement •

    $default  reduce using rule 36 (statement)


State 45

   37 statement: CONTINUE statement •

    $default  reduce using rule 37 (statement)


State 46

    7 thing: IDENTIFIER •

    $default  reduce using rule 7 (thing)


State 47

   64 return_: thing •

    $default  reduce using rule 64 (return_)


State 48

   63 return_stmt: RETURN return_ •

    $default  reduce using rule 63 (return_stmt)


State 49

    8 thing: literal •

    $default  reduce using rule 8 (thing)


State 50

    3 declaration: VAR IDENTIFIER • type
    4            | VAR IDENTIFIER • type ASSIGN expression
    5            | VAR IDENTIFIER • ASSIGN expression

    ASSIGN       shift, and go to state 92
    INT_TYPE     shift, and go to state 93
    BOOL_TYPE    shift, and go to state 94
    STRING_TYPE  shift, and go to state 95

    type  go to state 96


State 51

   80 println_stmt: PRINTLN LPAREN • IDENTIFIER RPAREN
   81             | PRINTLN LPAREN • STRING RPAREN

    IDENTIFIER  shift, and go to state 97
    STRING      shift, and go to state 98


State 52

   48 assignment: IDENTIFIER ASSIGN • expression

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term        go to state 78
    expression  go to state 99
    binary_op   go to state 80
    literal     go to state 40


State 53

   52 add_op_eq: ADD_ASSIGN •

    $default  reduce using rule 52 (add_op_eq)


State 54

   53 add_op_eq: SUB_ASSIGN •

    $default  reduce using rule 53 (add_op_eq)


State 55

   56 mul_op_eq: MUL_ASSIGN •

    $default  reduce using rule 56 (mul_op_eq)


State 56

   57 mul_op_eq: DIV_ASSIGN •

    $default  reduce using rule 57 (mul_op_eq)


State 57

   58 mul_op_eq: MOD_ASSIGN •

    $default  reduce using rule 58 (mul_op_eq)


State 58

   61 mul_op_eq: AND_ASSIGN •

    $default  reduce using rule 61 (mul_op_eq)


State 59

   54 add_op_eq: OR_ASSIGN •

    $default  reduce using rule 54 (add_op_eq)


State 60

   55 add_op_eq: XOR_ASSIGN •

    $default  reduce using rule 55 (add_op_eq)


State 61

   59 mul_op_eq: LEFT_SHIFT_ASSIGN •

    $default  reduce using rule 59 (mul_op_eq)


State 62

   60 mul_op_eq: RIGHT_SHIFT_ASSIGN •

    $default  reduce using rule 60 (mul_op_eq)


State 63

   46 inc_dec_stmt: IDENTIFIER INCREMENT •

    $default  reduce using rule 46 (inc_dec_stmt)


State 64

   47 inc_dec_stmt: IDENTIFIER DECREMENT •

    $default  reduce using rule 47 (inc_dec_stmt)


State 65

   62 mul_op_eq: CLEAR_ASSIGN •

    $default  reduce using rule 62 (mul_op_eq)


State 66

   49 assignment: IDENTIFIER assign_op • expression

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term        go to state 78
    expression  go to state 100
    binary_op   go to state 80
    literal     go to state 40


State 67

   50 assign_op: add_op_eq •

    $default  reduce using rule 50 (assign_op)


State 68

   51 assign_op: mul_op_eq •

    $default  reduce using rule 51 (assign_op)


State 69

   42 statement: COMMENT statement •

    $default  reduce using rule 42 (statement)


State 70

   33 statement: declaration statement •

    $default  reduce using rule 33 (statement)


State 71

   66 block_stmt: LBRACE statement RBRACE •

    $default  reduce using rule 66 (block_stmt)


State 72

   34 statement: simple_stmt statement •

    $default  reduce using rule 34 (statement)


State 73

   35 statement: return_stmt statement •

    $default  reduce using rule 35 (statement)


State 74

   38 statement: block_stmt statement •

    $default  reduce using rule 38 (statement)


State 75

   39 statement: if_stmt statement •

    $default  reduce using rule 39 (statement)


State 76

   40 statement: for_stmt statement •

    $default  reduce using rule 40 (statement)


State 77

   41 statement: println_stmt statement •

    $default  reduce using rule 41 (statement)


State 78

   12 expression: term •

    $default  reduce using rule 12 (expression)


State 79

   11 term: LPAREN expression • RPAREN
   14 binary_op: expression • LOGICAL_OR term
   15          | expression • LOGICAL_AND term
   16          | expression • EQUAL_EQUAL term
   17          | expression • NOT_EQUAL term
   18          | expression • LESS_THAN_OR_EQUAL term
   19          | expression • GREATER_THAN_OR_EQUAL term
   20          | expression • LESS_THAN term
   21          | expression • GREATER_THAN term
   22          | expression • PLUS term
   23          | expression • MINUS term
   24          | expression • BITWISE_OR term
   25          | expression • BITWISE_XOR term
   26          | expression • TIMES term
   27          | expression • DIVIDE term
   28          | expression • MODULO term
   29          | expression • RIGHT_SHIFT term
   30          | expression • LEFT_SHIFT term
   31          | expression • BITWISE_AND term
   32          | expression • BIT_CLEAR term

    PLUS                   shift, and go to state 101
    MINUS                  shift, and go to state 102
    TIMES                  shift, and go to state 103
    DIVIDE                 shift, and go to state 104
    MODULO                 shift, and go to state 105
    BITWISE_AND            shift, and go to state 106
    BITWISE_OR             shift, and go to state 107
    BITWISE_XOR            shift, and go to state 108
    BIT_CLEAR              shift, and go to state 109
    LEFT_SHIFT             shift, and go to state 110
    RIGHT_SHIFT            shift, and go to state 111
    EQUAL_EQUAL            shift, and go to state 112
    NOT_EQUAL              shift, and go to state 113
    LESS_THAN              shift, and go to state 114
    LESS_THAN_OR_EQUAL     shift, and go to state 115
    GREATER_THAN           shift, and go to state 116
    GREATER_THAN_OR_EQUAL  shift, and go to state 117
    LOGICAL_AND            shift, and go to state 118
    LOGICAL_OR             shift, and go to state 119
    RPAREN                 shift, and go to state 120


State 80

   13 expression: binary_op •

    $default  reduce using rule 13 (expression)


State 81

   69 boolean_exp: term EQUAL_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 121
    literal  go to state 40


State 82

   70 boolean_exp: term NOT_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 122
    literal  go to state 40


State 83

   73 boolean_exp: term LESS_THAN • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 123
    literal  go to state 40


State 84

   71 boolean_exp: term LESS_THAN_OR_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 124
    literal  go to state 40


State 85

   74 boolean_exp: term GREATER_THAN • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 125
    literal  go to state 40


State 86

   72 boolean_exp: term GREATER_THAN_OR_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 126
    literal  go to state 40


State 87

   68 boolean_exp: term LOGICAL_AND • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 127
    literal  go to state 40


State 88

   67 boolean_exp: term LOGICAL_OR • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 128
    literal  go to state 40


State 89

   75 if_stmt: IF boolean_exp block_stmt •
   76        | IF boolean_exp block_stmt • ELSE if_stmt
   77        | IF boolean_exp block_stmt • ELSE block_stmt

    ELSE  shift, and go to state 129

    $default  reduce using rule 75 (if_stmt)


State 90

   79 for_clause: assignment SEMICOLON • boolean_exp SEMICOLON simple_stmt

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term         go to state 38
    boolean_exp  go to state 130
    literal      go to state 40


State 91

   78 for_stmt: FOR for_clause block_stmt •

    $default  reduce using rule 78 (for_stmt)


State 92

    5 declaration: VAR IDENTIFIER ASSIGN • expression

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term        go to state 78
    expression  go to state 131
    binary_op   go to state 80
    literal     go to state 40


State 93

   82 type: INT_TYPE •

    $default  reduce using rule 82 (type)


State 94

   84 type: BOOL_TYPE •

    $default  reduce using rule 84 (type)


State 95

   83 type: STRING_TYPE •

    $default  reduce using rule 83 (type)


State 96

    3 declaration: VAR IDENTIFIER type •
    4            | VAR IDENTIFIER type • ASSIGN expression

    ASSIGN  shift, and go to state 132

    $default  reduce using rule 3 (declaration)


State 97

   80 println_stmt: PRINTLN LPAREN IDENTIFIER • RPAREN

    RPAREN  shift, and go to state 133


State 98

   81 println_stmt: PRINTLN LPAREN STRING • RPAREN

    RPAREN  shift, and go to state 134


State 99

   14 binary_op: expression • LOGICAL_OR term
   15          | expression • LOGICAL_AND term
   16          | expression • EQUAL_EQUAL term
   17          | expression • NOT_EQUAL term
   18          | expression • LESS_THAN_OR_EQUAL term
   19          | expression • GREATER_THAN_OR_EQUAL term
   20          | expression • LESS_THAN term
   21          | expression • GREATER_THAN term
   22          | expression • PLUS term
   23          | expression • MINUS term
   24          | expression • BITWISE_OR term
   25          | expression • BITWISE_XOR term
   26          | expression • TIMES term
   27          | expression • DIVIDE term
   28          | expression • MODULO term
   29          | expression • RIGHT_SHIFT term
   30          | expression • LEFT_SHIFT term
   31          | expression • BITWISE_AND term
   32          | expression • BIT_CLEAR term
   48 assignment: IDENTIFIER ASSIGN expression •

    PLUS                   shift, and go to state 101
    MINUS                  shift, and go to state 102
    TIMES                  shift, and go to state 103
    DIVIDE                 shift, and go to state 104
    MODULO                 shift, and go to state 105
    BITWISE_AND            shift, and go to state 106
    BITWISE_OR             shift, and go to state 107
    BITWISE_XOR            shift, and go to state 108
    BIT_CLEAR              shift, and go to state 109
    LEFT_SHIFT             shift, and go to state 110
    RIGHT_SHIFT            shift, and go to state 111
    EQUAL_EQUAL            shift, and go to state 112
    NOT_EQUAL              shift, and go to state 113
    LESS_THAN              shift, and go to state 114
    LESS_THAN_OR_EQUAL     shift, and go to state 115
    GREATER_THAN           shift, and go to state 116
    GREATER_THAN_OR_EQUAL  shift, and go to state 117
    LOGICAL_AND            shift, and go to state 118
    LOGICAL_OR             shift, and go to state 119

    $default  reduce using rule 48 (assignment)


State 100

   14 binary_op: expression • LOGICAL_OR term
   15          | expression • LOGICAL_AND term
   16          | expression • EQUAL_EQUAL term
   17          | expression • NOT_EQUAL term
   18          | expression • LESS_THAN_OR_EQUAL term
   19          | expression • GREATER_THAN_OR_EQUAL term
   20          | expression • LESS_THAN term
   21          | expression • GREATER_THAN term
   22          | expression • PLUS term
   23          | expression • MINUS term
   24          | expression • BITWISE_OR term
   25          | expression • BITWISE_XOR term
   26          | expression • TIMES term
   27          | expression • DIVIDE term
   28          | expression • MODULO term
   29          | expression • RIGHT_SHIFT term
   30          | expression • LEFT_SHIFT term
   31          | expression • BITWISE_AND term
   32          | expression • BIT_CLEAR term
   49 assignment: IDENTIFIER assign_op expression •

    PLUS                   shift, and go to state 101
    MINUS                  shift, and go to state 102
    TIMES                  shift, and go to state 103
    DIVIDE                 shift, and go to state 104
    MODULO                 shift, and go to state 105
    BITWISE_AND            shift, and go to state 106
    BITWISE_OR             shift, and go to state 107
    BITWISE_XOR            shift, and go to state 108
    BIT_CLEAR              shift, and go to state 109
    LEFT_SHIFT             shift, and go to state 110
    RIGHT_SHIFT            shift, and go to state 111
    EQUAL_EQUAL            shift, and go to state 112
    NOT_EQUAL              shift, and go to state 113
    LESS_THAN              shift, and go to state 114
    LESS_THAN_OR_EQUAL     shift, and go to state 115
    GREATER_THAN           shift, and go to state 116
    GREATER_THAN_OR_EQUAL  shift, and go to state 117
    LOGICAL_AND            shift, and go to state 118
    LOGICAL_OR             shift, and go to state 119

    $default  reduce using rule 49 (assignment)


State 101

   22 binary_op: expression PLUS • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 135
    literal  go to state 40


State 102

   23 binary_op: expression MINUS • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 136
    literal  go to state 40


State 103

   26 binary_op: expression TIMES • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 137
    literal  go to state 40


State 104

   27 binary_op: expression DIVIDE • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 138
    literal  go to state 40


State 105

   28 binary_op: expression MODULO • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 139
    literal  go to state 40


State 106

   31 binary_op: expression BITWISE_AND • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 140
    literal  go to state 40


State 107

   24 binary_op: expression BITWISE_OR • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 141
    literal  go to state 40


State 108

   25 binary_op: expression BITWISE_XOR • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 142
    literal  go to state 40


State 109

   32 binary_op: expression BIT_CLEAR • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 143
    literal  go to state 40


State 110

   30 binary_op: expression LEFT_SHIFT • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 144
    literal  go to state 40


State 111

   29 binary_op: expression RIGHT_SHIFT • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 145
    literal  go to state 40


State 112

   16 binary_op: expression EQUAL_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 146
    literal  go to state 40


State 113

   17 binary_op: expression NOT_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 147
    literal  go to state 40


State 114

   20 binary_op: expression LESS_THAN • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 148
    literal  go to state 40


State 115

   18 binary_op: expression LESS_THAN_OR_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 149
    literal  go to state 40


State 116

   21 binary_op: expression GREATER_THAN • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 150
    literal  go to state 40


State 117

   19 binary_op: expression GREATER_THAN_OR_EQUAL • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 151
    literal  go to state 40


State 118

   15 binary_op: expression LOGICAL_AND • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 152
    literal  go to state 40


State 119

   14 binary_op: expression LOGICAL_OR • term

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term     go to state 153
    literal  go to state 40


State 120

   11 term: LPAREN expression RPAREN •

    $default  reduce using rule 11 (term)


State 121

   69 boolean_exp: term EQUAL_EQUAL term •

    $default  reduce using rule 69 (boolean_exp)


State 122

   70 boolean_exp: term NOT_EQUAL term •

    $default  reduce using rule 70 (boolean_exp)


State 123

   73 boolean_exp: term LESS_THAN term •

    $default  reduce using rule 73 (boolean_exp)


State 124

   71 boolean_exp: term LESS_THAN_OR_EQUAL term •

    $default  reduce using rule 71 (boolean_exp)


State 125

   74 boolean_exp: term GREATER_THAN term •

    $default  reduce using rule 74 (boolean_exp)


State 126

   72 boolean_exp: term GREATER_THAN_OR_EQUAL term •

    $default  reduce using rule 72 (boolean_exp)


State 127

   68 boolean_exp: term LOGICAL_AND term •

    $default  reduce using rule 68 (boolean_exp)


State 128

   67 boolean_exp: term LOGICAL_OR term •

    $default  reduce using rule 67 (boolean_exp)


State 129

   76 if_stmt: IF boolean_exp block_stmt ELSE • if_stmt
   77        | IF boolean_exp block_stmt ELSE • block_stmt

    IF      shift, and go to state 13
    LBRACE  shift, and go to state 11

    block_stmt  go to state 154
    if_stmt     go to state 155


State 130

   79 for_clause: assignment SEMICOLON boolean_exp • SEMICOLON simple_stmt

    SEMICOLON  shift, and go to state 156


State 131

    5 declaration: VAR IDENTIFIER ASSIGN expression •
   14 binary_op: expression • LOGICAL_OR term
   15          | expression • LOGICAL_AND term
   16          | expression • EQUAL_EQUAL term
   17          | expression • NOT_EQUAL term
   18          | expression • LESS_THAN_OR_EQUAL term
   19          | expression • GREATER_THAN_OR_EQUAL term
   20          | expression • LESS_THAN term
   21          | expression • GREATER_THAN term
   22          | expression • PLUS term
   23          | expression • MINUS term
   24          | expression • BITWISE_OR term
   25          | expression • BITWISE_XOR term
   26          | expression • TIMES term
   27          | expression • DIVIDE term
   28          | expression • MODULO term
   29          | expression • RIGHT_SHIFT term
   30          | expression • LEFT_SHIFT term
   31          | expression • BITWISE_AND term
   32          | expression • BIT_CLEAR term

    PLUS                   shift, and go to state 101
    MINUS                  shift, and go to state 102
    TIMES                  shift, and go to state 103
    DIVIDE                 shift, and go to state 104
    MODULO                 shift, and go to state 105
    BITWISE_AND            shift, and go to state 106
    BITWISE_OR             shift, and go to state 107
    BITWISE_XOR            shift, and go to state 108
    BIT_CLEAR              shift, and go to state 109
    LEFT_SHIFT             shift, and go to state 110
    RIGHT_SHIFT            shift, and go to state 111
    EQUAL_EQUAL            shift, and go to state 112
    NOT_EQUAL              shift, and go to state 113
    LESS_THAN              shift, and go to state 114
    LESS_THAN_OR_EQUAL     shift, and go to state 115
    GREATER_THAN           shift, and go to state 116
    GREATER_THAN_OR_EQUAL  shift, and go to state 117
    LOGICAL_AND            shift, and go to state 118
    LOGICAL_OR             shift, and go to state 119

    $default  reduce using rule 5 (declaration)


State 132

    4 declaration: VAR IDENTIFIER type ASSIGN • expression

    LPAREN      shift, and go to state 32
    BOOLEAN     shift, and go to state 33
    IDENTIFIER  shift, and go to state 34
    INTEGER     shift, and go to state 35
    STRING      shift, and go to state 36
    FLOAT       shift, and go to state 37

    term        go to state 78
    expression  go to state 157
    binary_op   go to state 80
    literal     go to state 40


State 133

   80 println_stmt: PRINTLN LPAREN IDENTIFIER RPAREN •

    $default  reduce using rule 80 (println_stmt)


State 134

   81 println_stmt: PRINTLN LPAREN STRING RPAREN •

    $default  reduce using rule 81 (println_stmt)


State 135

   22 binary_op: expression PLUS term •

    $default  reduce using rule 22 (binary_op)


State 136

   23 binary_op: expression MINUS term •

    $default  reduce using rule 23 (binary_op)


State 137

   26 binary_op: expression TIMES term •

    $default  reduce using rule 26 (binary_op)


State 138

   27 binary_op: expression DIVIDE term •

    $default  reduce using rule 27 (binary_op)


State 139

   28 binary_op: expression MODULO term •

    $default  reduce using rule 28 (binary_op)


State 140

   31 binary_op: expression BITWISE_AND term •

    $default  reduce using rule 31 (binary_op)


State 141

   24 binary_op: expression BITWISE_OR term •

    $default  reduce using rule 24 (binary_op)


State 142

   25 binary_op: expression BITWISE_XOR term •

    $default  reduce using rule 25 (binary_op)


State 143

   32 binary_op: expression BIT_CLEAR term •

    $default  reduce using rule 32 (binary_op)


State 144

   30 binary_op: expression LEFT_SHIFT term •

    $default  reduce using rule 30 (binary_op)


State 145

   29 binary_op: expression RIGHT_SHIFT term •

    $default  reduce using rule 29 (binary_op)


State 146

   16 binary_op: expression EQUAL_EQUAL term •

    $default  reduce using rule 16 (binary_op)


State 147

   17 binary_op: expression NOT_EQUAL term •

    $default  reduce using rule 17 (binary_op)


State 148

   20 binary_op: expression LESS_THAN term •

    $default  reduce using rule 20 (binary_op)


State 149

   18 binary_op: expression LESS_THAN_OR_EQUAL term •

    $default  reduce using rule 18 (binary_op)


State 150

   21 binary_op: expression GREATER_THAN term •

    $default  reduce using rule 21 (binary_op)


State 151

   19 binary_op: expression GREATER_THAN_OR_EQUAL term •

    $default  reduce using rule 19 (binary_op)


State 152

   15 binary_op: expression LOGICAL_AND term •

    $default  reduce using rule 15 (binary_op)


State 153

   14 binary_op: expression LOGICAL_OR term •

    $default  reduce using rule 14 (binary_op)


State 154

   77 if_stmt: IF boolean_exp block_stmt ELSE block_stmt •

    $default  reduce using rule 77 (if_stmt)


State 155

   76 if_stmt: IF boolean_exp block_stmt ELSE if_stmt •

    $default  reduce using rule 76 (if_stmt)


State 156

   79 for_clause: assignment SEMICOLON boolean_exp SEMICOLON • simple_stmt

    IDENTIFIER  shift, and go to state 20

    simple_stmt   go to state 158
    inc_dec_stmt  go to state 25
    assignment    go to state 26


State 157

    4 declaration: VAR IDENTIFIER type ASSIGN expression •
   14 binary_op: expression • LOGICAL_OR term
   15          | expression • LOGICAL_AND term
   16          | expression • EQUAL_EQUAL term
   17          | expression • NOT_EQUAL term
   18          | expression • LESS_THAN_OR_EQUAL term
   19          | expression • GREATER_THAN_OR_EQUAL term
   20          | expression • LESS_THAN term
   21          | expression • GREATER_THAN term
   22          | expression • PLUS term
   23          | expression • MINUS term
   24          | expression • BITWISE_OR term
   25          | expression • BITWISE_XOR term
   26          | expression • TIMES term
   27          | expression • DIVIDE term
   28          | expression • MODULO term
   29          | expression • RIGHT_SHIFT term
   30          | expression • LEFT_SHIFT term
   31          | expression • BITWISE_AND term
   32          | expression • BIT_CLEAR term

    PLUS                   shift, and go to state 101
    MINUS                  shift, and go to state 102
    TIMES                  shift, and go to state 103
    DIVIDE                 shift, and go to state 104
    MODULO                 shift, and go to state 105
    BITWISE_AND            shift, and go to state 106
    BITWISE_OR             shift, and go to state 107
    BITWISE_XOR            shift, and go to state 108
    BIT_CLEAR              shift, and go to state 109
    LEFT_SHIFT             shift, and go to state 110
    RIGHT_SHIFT            shift, and go to state 111
    EQUAL_EQUAL            shift, and go to state 112
    NOT_EQUAL              shift, and go to state 113
    LESS_THAN              shift, and go to state 114
    LESS_THAN_OR_EQUAL     shift, and go to state 115
    GREATER_THAN           shift, and go to state 116
    GREATER_THAN_OR_EQUAL  shift, and go to state 117
    LOGICAL_AND            shift, and go to state 118
    LOGICAL_OR             shift, and go to state 119

    $default  reduce using rule 4 (declaration)


State 158

   79 for_clause: assignment SEMICOLON boolean_exp SEMICOLON simple_stmt •

    $default  reduce using rule 79 (for_clause)
